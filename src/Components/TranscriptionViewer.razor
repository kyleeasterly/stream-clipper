@using StreamClipper.Models
@using StreamClipper.Services
@inject TranscriptionService TranscriptionService
@inject TopicSegmentationService TopicSegmentationService
@inject ISnackbar Snackbar
@inject ILogger<TranscriptionViewer> Logger

<MudGrid>
    @if (Transcription != null)
    {
        <MudItem xs="12">
            <MudPaper Class="pa-3 mb-3">
                <MudGrid>
                    <MudItem xs="12" md="8">
                        <MudText Typo="Typo.subtitle1" Color="Color.Primary">
                            @TranscriptionService.GetTranscriptionSummary(Transcription)
                        </MudText>
                    </MudItem>
                    <MudItem xs="12" md="4" Class="d-flex justify-end align-center">
                        @if (Project != null)
                        {
                            <MudButton Variant="Variant.Filled"
                                     Color="@(Project.HasUnsavedChanges ? Color.Warning : Color.Default)"
                                     StartIcon="@Icons.Material.Filled.Save"
                                     OnClick="SaveProject"
                                     Disabled="@_isSaving">
                                @if (_isSaving)
                                {
                                    <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                    <MudText Class="ms-2">Saving...</MudText>
                                }
                                else if (Project.HasUnsavedChanges)
                                {
                                    <MudText>Save Changes</MudText>
                                }
                                else
                                {
                                    <MudText>Save Project</MudText>
                                }
                            </MudButton>
                            
                            @if (Project.LastSavedAt.HasValue)
                            {
                                <MudText Typo="Typo.caption" Class="ml-2">
                                    Last saved: @Project.LastSavedAt.Value.ToLocalTime().ToString("g")
                                </MudText>
                            }
                        }
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="4">
            <MudPaper Class="pa-3" Style="height: 600px; overflow-y: auto;">
                <MudText Typo="Typo.h6" Class="mb-3">Segments</MudText>
                <MudTextField @bind-Value="_searchText" 
                            Label="Search transcription" 
                            Variant="Variant.Outlined"
                            Adornment="Adornment.End"
                            AdornmentIcon="@Icons.Material.Filled.Search"
                            Class="mb-3" />
                
                <MudList T="TranscriptionSegment" Dense="true">
                    @foreach (var segment in GetFilteredSegments())
                    {
                        <MudListItem T="TranscriptionSegment" 
                                   OnClick="@(() => SelectSegment(segment))"
                                   Style="@(segment == _selectedSegment ? "background-color: var(--mud-palette-primary-hover);" : "cursor: pointer;")">
                            <div>
                                @if (Project?.Topics?.Any() == true)
                                {
                                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text" Class="pa-1 mb-1">
                                        @GetTopicPathForSegment(segment.Id)
                                    </MudChip>
                                }
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    #@segment.Id | @TranscriptionService.FormatTimestamp(segment.Start) - @TranscriptionService.FormatTimestamp(segment.End)
                                </MudText>
                                <MudText Typo="Typo.body2" Class="text-truncate">
                                    @segment.Text.Trim()
                                </MudText>
                            </div>
                        </MudListItem>
                        <MudDivider />
                    }
                </MudList>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="8">
            <MudPaper Class="pa-3" Style="height: 600px; overflow-y: auto;">
                <MudText Typo="Typo.h6" Class="mb-3">Detailed View</MudText>
                
                @if (_selectedSegment != null)
                {
                    <MudCard Elevation="0">
                        <MudCardContent>
                            <MudGrid>
                                <MudItem xs="12">
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">
                                        Segment #@(_selectedSegment.Id) | @TranscriptionService.FormatTimestamp(_selectedSegment.Start) - @TranscriptionService.FormatTimestamp(_selectedSegment.End)
                                    </MudText>
                                </MudItem>
                                
                                <MudItem xs="12">
                                    <MudText Typo="Typo.body1" Class="mt-2 mb-3">
                                        @_selectedSegment.Text
                                    </MudText>
                                </MudItem>

                                @if (_selectedSegment.Words != null && _selectedSegment.Words.Any())
                                {
                                    <MudItem xs="12">
                                        <MudText Typo="Typo.subtitle2" Class="mb-2">Word-level Timestamps</MudText>
                                        <MudPaper Elevation="1" Class="pa-2" Style="max-height: 300px; overflow-y: auto;">
                                            <MudGrid Spacing="1">
                                                @foreach (var word in _selectedSegment.Words)
                                                {
                                                    <MudItem xs="12" sm="6" md="4" lg="3">
                                                        <MudChip T="string" Size="Size.Small" 
                                                               Color="@GetWordConfidenceColor(word.Probability)"
                                                               Variant="Variant.Outlined">
                                                            <MudTooltip Text="@($"{TranscriptionService.FormatTimestamp(word.Start)} - {TranscriptionService.FormatTimestamp(word.End)} | Confidence: {word.Probability:P0}")">
                                                                <MudText Typo="Typo.caption">@word.Word</MudText>
                                                            </MudTooltip>
                                                        </MudChip>
                                                    </MudItem>
                                                }
                                            </MudGrid>
                                        </MudPaper>
                                    </MudItem>
                                }

                                <MudItem xs="12">
                                    <MudText Typo="Typo.subtitle2" Class="mt-3 mb-2">Technical Details</MudText>
                                    <MudSimpleTable Hover="true" Dense="true">
                                        <tbody>
                                            <tr>
                                                <td><MudText Typo="Typo.caption">Temperature</MudText></td>
                                                <td><MudText Typo="Typo.caption">@_selectedSegment.Temperature.ToString("F3")</MudText></td>
                                            </tr>
                                            <tr>
                                                <td><MudText Typo="Typo.caption">Avg Log Probability</MudText></td>
                                                <td><MudText Typo="Typo.caption">@_selectedSegment.AvgLogprob.ToString("F3")</MudText></td>
                                            </tr>
                                            <tr>
                                                <td><MudText Typo="Typo.caption">Compression Ratio</MudText></td>
                                                <td><MudText Typo="Typo.caption">@_selectedSegment.CompressionRatio.ToString("F3")</MudText></td>
                                            </tr>
                                            <tr>
                                                <td><MudText Typo="Typo.caption">No Speech Probability</MudText></td>
                                                <td><MudText Typo="Typo.caption">@_selectedSegment.NoSpeechProb.ToString("P1")</MudText></td>
                                            </tr>
                                        </tbody>
                                    </MudSimpleTable>
                                </MudItem>
                            </MudGrid>
                        </MudCardContent>
                    </MudCard>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-4">
                        Select a segment from the list to view details
                    </MudText>
                }
            </MudPaper>
        </MudItem>

        <MudItem xs="12">
            <MudPaper Class="pa-3">
                <div Class="d-flex justify-space-between align-center mb-3">
                    <MudText Typo="Typo.h6">Topic Outline</MudText>
                    @if (Project == null && Transcription != null)
                    {
                        <MudButton Variant="Variant.Filled"
                                 Color="Color.Primary"
                                 StartIcon="@Icons.Material.Filled.AutoAwesome"
                                 OnClick="AnalyzeTopics"
                                 Disabled="@_isProcessingTopics">
                            @if (_isProcessingTopics)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Analyzing...</MudText>
                            }
                            else
                            {
                                <MudText>Analyze Topics with GPT-5</MudText>
                            }
                        </MudButton>
                    }
                </div>
                
                @if (Project?.Topics?.Any() == true)
                {
                    <MudPaper Elevation="1" Class="pa-3 mb-3" Style="max-height: 600px; overflow-y: auto;">
                        @foreach (var topic in Project.Topics)
                        {
                            <TopicTreeItem Topic="@topic"
                                         Level="0"
                                         IsExpanded="@IsTopicExpanded(topic)"
                                         IsProcessing="@(_processingTopics.Contains(topic.Id))"
                                         ProcessingTopics="@_processingTopics"
                                         IsExpandedFunc="@IsTopicExpanded"
                                         OnToggleExpansion="@HandleToggleExpansion"
                                         OnTopicClick="@HandleTopicClick"
                                         OnRegenerate="@RegenerateTopic" />
                        }
                    </MudPaper>
                }
                
                <MudPaper Elevation="1" Class="pa-3" Style="max-height: 400px; overflow-y: auto;">
                    <MudText Typo="Typo.h6" Class="mb-2">Full Transcript</MudText>
                    <MudText Typo="Typo.body1" Style="white-space: pre-wrap;">
                        @(Transcription?.Text ?? "")
                    </MudText>
                </MudPaper>
            </MudPaper>
        </MudItem>
    }
    else
    {
        <MudItem xs="12">
            <MudPaper Class="pa-4 text-center">
                <MudIcon Icon="@Icons.Material.Filled.Subtitles" Size="Size.Large" Color="Color.Secondary" />
                <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mt-3">
                    No transcription loaded
                </MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    Process a video file or load an existing JSON transcription
                </MudText>
            </MudPaper>
        </MudItem>
    }
</MudGrid>

@code {
    [Parameter] public WhisperTranscription? Transcription { get; set; }
    [Parameter] public StreamClipperProject? Project { get; set; }
    [Parameter] public EventCallback<TranscriptionSegment> OnSegmentSelected { get; set; }
    [Parameter] public EventCallback<StreamClipperProject> OnProjectCreated { get; set; }
    [Parameter] public EventCallback<StreamClipperProject> OnProjectUpdated { get; set; }

    private TranscriptionSegment? _selectedSegment;
    private string _searchText = string.Empty;
    private bool _isProcessingTopics = false;
    private bool _isSaving = false;
    private HashSet<string> _processingTopics = new();
    private HashSet<string> _expandedTopics = new();

    private IEnumerable<TranscriptionSegment> GetFilteredSegments()
    {
        if (Transcription?.Segments == null)
            return Enumerable.Empty<TranscriptionSegment>();

        if (string.IsNullOrWhiteSpace(_searchText))
            return Transcription.Segments;

        return Transcription.Segments.Where(s => 
            s.Text.Contains(_searchText, StringComparison.OrdinalIgnoreCase));
    }

    private void SelectSegment(TranscriptionSegment segment)
    {
        _selectedSegment = segment;
        OnSegmentSelected.InvokeAsync(segment);
    }

    private Color GetWordConfidenceColor(double? probability)
    {
        if (!probability.HasValue)
            return Color.Default;

        return probability.Value switch
        {
            >= 0.9 => Color.Success,
            >= 0.7 => Color.Warning,
            _ => Color.Error
        };
    }
    
    private async Task AnalyzeTopics()
    {
        if (Transcription == null)
            return;
            
        _isProcessingTopics = true;
        StateHasChanged();
        
        try
        {
            var project = await TopicSegmentationService.CreateProjectAsync(
                Transcription,
                null, // video path would come from parent
                null  // json path would come from parent
            );
            
            await OnProjectCreated.InvokeAsync(project);
            Snackbar.Add("Topics analyzed and project created successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to analyze topics: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isProcessingTopics = false;
            StateHasChanged();
        }
    }
    
    private bool IsTopicExpanded(TopicSegment topic) => _expandedTopics.Contains(topic.Id);
    
    private async Task HandleToggleExpansion(TopicSegment topic)
    {
        if (_expandedTopics.Contains(topic.Id))
            _expandedTopics.Remove(topic.Id);
        else
            _expandedTopics.Add(topic.Id);
        StateHasChanged();
        await Task.CompletedTask;
    }
    
    private async Task HandleTopicClick(TopicSegment topic)
    {
        Logger.LogInformation($"Topic clicked: '{topic.Topic}' [{topic.StartSegmentId}-{topic.EndSegmentId}]");
        
        if (topic.IsSingleSegment || _processingTopics.Contains(topic.Id) || Transcription?.Segments == null)
        {
            if (topic.IsSingleSegment)
                Logger.LogDebug($"Topic '{topic.Topic}' is a single segment - cannot drill down");
            if (_processingTopics.Contains(topic.Id))
                Logger.LogDebug($"Already processing topic '{topic.Id}' - ignoring click");
            if (Transcription?.Segments == null)
                Logger.LogWarning("No transcription segments available");
            return;
        }
            
        // If topic already has children, just expand/collapse
        if (topic.HasChildren)
        {
            Logger.LogDebug($"Topic '{topic.Topic}' already has {topic.Children?.Count} children - toggling expansion");
            await HandleToggleExpansion(topic);
            return;
        }
        
        Logger.LogInformation($"🚀 Starting sub-topic generation for: '{topic.Topic}'");
        Logger.LogInformation($"Topic range: Segments {topic.StartSegmentId} to {topic.EndSegmentId} ({topic.SegmentCount} segments)");
        
        _processingTopics.Add(topic.Id);
        StateHasChanged();
        
        try
        {
            Logger.LogDebug($"Calling TopicSegmentationService.SegmentSubtopicAsync...");
            var subTopics = await TopicSegmentationService.SegmentSubtopicAsync(topic, Transcription.Segments);
            
            Logger.LogInformation($"Received {subTopics.Count} sub-topics from segmentation service");
            
            if (subTopics.Any())
            {
                topic.Children = subTopics;
                _expandedTopics.Add(topic.Id);
                
                Logger.LogDebug("Sub-topics generated:");
                foreach (var subTopic in subTopics)
                {
                    Logger.LogDebug($"  - [{subTopic.StartSegmentId}-{subTopic.EndSegmentId}] {subTopic.Topic}");
                }
                
                if (Project != null)
                {
                    Project.HasUnsavedChanges = true;
                    await OnProjectUpdated.InvokeAsync(Project);
                    Logger.LogDebug("Project marked as having unsaved changes");
                }
                
                var message = $"Generated {subTopics.Count} sub-topics for '{topic.Topic}'";
                Logger.LogInformation($"✅ {message}");
                Snackbar.Add(message, Severity.Success);
            }
            else
            {
                Logger.LogWarning($"No sub-topics could be identified for '{topic.Topic}'");
                Snackbar.Add("No sub-topics could be identified", Severity.Info);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to generate sub-topics for '{topic.Topic}'");
            Snackbar.Add($"Failed to generate sub-topics: {ex.Message}", Severity.Error);
        }
        finally
        {
            Logger.LogDebug($"Clearing processing state for topic '{topic.Topic}'");
            _processingTopics.Remove(topic.Id);
            StateHasChanged();
        }
    }
    
    private async Task RegenerateTopic(TopicSegment topic)
    {
        if (!topic.CanRegenerate || _processingTopics.Contains(topic.Id) || Project == null || Transcription?.Segments == null)
            return;
            
        _processingTopics.Add(topic.Id);
        StateHasChanged();
        
        try
        {
            // Find parent topic if this is not a top-level topic
            var parentTopic = FindParentTopic(Project.Topics, topic);
            
            List<TopicSegment> newTopics;
            if (parentTopic != null)
            {
                // Regenerating a sub-topic
                newTopics = await TopicSegmentationService.SegmentSubtopicAsync(parentTopic, Transcription.Segments);
                if (newTopics.Any())
                {
                    parentTopic.Children = newTopics;
                }
            }
            else
            {
                // Regenerating top-level topics
                newTopics = await TopicSegmentationService.RegenerateTopicAsync(topic, Transcription.Segments, null);
                if (newTopics.Any())
                {
                    Project.Topics = newTopics;
                }
            }
            
            Project.HasUnsavedChanges = true;
            await OnProjectUpdated.InvokeAsync(Project);
            
            Snackbar.Add("Topics regenerated successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to regenerate topics: {ex.Message}", Severity.Error);
        }
        finally
        {
            _processingTopics.Remove(topic.Id);
            StateHasChanged();
        }
    }
    
    private TopicSegment? FindParentTopic(List<TopicSegment> topics, TopicSegment childTopic)
    {
        foreach (var topic in topics)
        {
            if (topic.Children?.Any(c => c.Id == childTopic.Id) == true)
            {
                return topic;
            }
            
            if (topic.Children != null)
            {
                var found = FindParentTopic(topic.Children, childTopic);
                if (found != null)
                    return found;
            }
        }
        return null;
    }
    
    private async Task SaveProject()
    {
        if (Project == null)
            return;
            
        _isSaving = true;
        StateHasChanged();
        
        try
        {
            await TopicSegmentationService.SaveProjectManuallyAsync(Project);
            await OnProjectUpdated.InvokeAsync(Project);
            Snackbar.Add("Project saved successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save project: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }
    
    private string GetTopicPathForSegment(int segmentId)
    {
        if (Project?.Topics == null)
            return "Unknown Topic";
            
        var path = new List<string>();
        FindTopicPath(Project.Topics, segmentId, path);
        
        return path.Any() ? string.Join(" > ", path) : "Unknown Topic";
    }
    
    private bool FindTopicPath(List<TopicSegment> topics, int segmentId, List<string> path)
    {
        foreach (var topic in topics)
        {
            if (segmentId >= topic.StartSegmentId && segmentId <= topic.EndSegmentId)
            {
                path.Add(topic.Topic);
                
                if (topic.Children != null)
                {
                    FindTopicPath(topic.Children, segmentId, path);
                }
                
                return true;
            }
        }
        return false;
    }
}